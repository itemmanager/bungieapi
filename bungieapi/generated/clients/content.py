# generated by update to not change manually
import dataclasses as dt
import typing as t

from bungieapi.base import BaseClient
from bungieapi.forge import forge
from bungieapi.generated.types import SearchResultOfContentItemPublicContract
from bungieapi.generated.types.content import ContentItemPublicContract
from bungieapi.generated.types.content.models import ContentTypeDescription
from bungieapi.generated.types.exceptions import PlatformErrorCodes


@dt.dataclass(frozen=True)
class GetContentTypeClientResponse:
    response: "ContentTypeDescription"
    error_code: "PlatformErrorCodes"
    throttle_seconds: int
    error_status: str
    message: str
    message_data: t.Mapping[str, str]
    detailed_error_trace: str


@dt.dataclass(frozen=True)
class GetContentByIdClientResponse:
    response: "ContentItemPublicContract"
    error_code: "PlatformErrorCodes"
    throttle_seconds: int
    error_status: str
    message: str
    message_data: t.Mapping[str, str]
    detailed_error_trace: str


@dt.dataclass(frozen=True)
class GetContentByTagAndTypeClientResponse:
    response: "ContentItemPublicContract"
    error_code: "PlatformErrorCodes"
    throttle_seconds: int
    error_status: str
    message: str
    message_data: t.Mapping[str, str]
    detailed_error_trace: str


@dt.dataclass(frozen=True)
class SearchContentWithTextClientResponse:
    response: "SearchResultOfContentItemPublicContract"
    error_code: "PlatformErrorCodes"
    throttle_seconds: int
    error_status: str
    message: str
    message_data: t.Mapping[str, str]
    detailed_error_trace: str


@dt.dataclass(frozen=True)
class SearchContentByTagAndTypeClientResponse:
    response: "SearchResultOfContentItemPublicContract"
    error_code: "PlatformErrorCodes"
    throttle_seconds: int
    error_status: str
    message: str
    message_data: t.Mapping[str, str]
    detailed_error_trace: str


@dt.dataclass(frozen=True)
class SearchHelpArticlesClientResponse:
    response: t.Any
    error_code: "PlatformErrorCodes"
    throttle_seconds: int
    error_status: str
    message: str
    message_data: t.Mapping[str, str]
    detailed_error_trace: str


class Client(BaseClient):
    async def get_content_type(
        self,
        type: str,
    ) -> GetContentTypeClientResponse:
        """Gets an object describing a particular variant of content."""
        query = None
        result = await self.get(path=f"/Content/GetContentType/{type}/", query=query)
        return forge(GetContentTypeClientResponse, result)

    async def get_content_by_id(
        self,
        id: int,
        locale: str,
        head: t.Optional[bool] = None,
    ) -> GetContentByIdClientResponse:
        """Returns a content item referenced by id
        Parameters:
            head: false"""
        query = {"head": head}
        result = await self.get(
            path=f"/Content/GetContentById/{id}/{locale}/", query=query
        )
        return forge(GetContentByIdClientResponse, result)

    async def get_content_by_tag_and_type(
        self,
        locale: str,
        tag: str,
        type: str,
        head: t.Optional[bool] = None,
    ) -> GetContentByTagAndTypeClientResponse:
        """Returns the newest item that matches a given tag and Content Type.

        Parameters:
            head: Not used.
        """
        query = {"head": head}
        result = await self.get(
            path=f"/Content/GetContentByTagAndType/{tag}/{type}/{locale}/", query=query
        )
        return forge(GetContentByTagAndTypeClientResponse, result)

    async def search_content_with_text(
        self,
        locale: str,
        ctype: t.Optional[str] = None,
        currentpage: t.Optional[int] = None,
        head: t.Optional[bool] = None,
        searchtext: t.Optional[str] = None,
        source: t.Optional[str] = None,
        tag: t.Optional[str] = None,
    ) -> SearchContentWithTextClientResponse:
        """Gets content based on querystring information passed in.

        Provides basic search and text search capabilities.
        Parameters:
            ctype: Content type tag: Help, News, etc. Supply multiple ctypes separated by space.
            currentpage: Page number for the search results, starting with page 1.
            head: Not used.
            searchtext: Word or phrase for the search.
            source: For analytics, hint at the part of the app that triggered the search. Optional.
            tag: Tag used on the content to be searched.
        """
        query = {
            "ctype": ctype,
            "currentpage": currentpage,
            "head": head,
            "searchtext": searchtext,
            "source": source,
            "tag": tag,
        }
        result = await self.get(path=f"/Content/Search/{locale}/", query=query)
        return forge(SearchContentWithTextClientResponse, result)

    async def search_content_by_tag_and_type(
        self,
        locale: str,
        tag: str,
        type: str,
        currentpage: t.Optional[int] = None,
        head: t.Optional[bool] = None,
        itemsperpage: t.Optional[int] = None,
    ) -> SearchContentByTagAndTypeClientResponse:
        """Searches for Content Items that match the given Tag and Content
        Type.

        Parameters:
            currentpage: Page number for the search results starting with page 1.
            head: Not used.
            itemsperpage: Not used.
        """
        query = {"currentpage": currentpage, "head": head, "itemsperpage": itemsperpage}
        result = await self.get(
            path=f"/Content/SearchContentByTagAndType/{tag}/{type}/{locale}/",
            query=query,
        )
        return forge(SearchContentByTagAndTypeClientResponse, result)

    async def search_help_articles(
        self,
        searchtext: str,
        size: str,
    ) -> SearchHelpArticlesClientResponse:
        """Search for Help Articles."""
        query = None
        result = await self.get(
            path=f"/Content/SearchHelpArticles/{searchtext}/{size}/", query=query
        )
        return forge(SearchHelpArticlesClientResponse, result)
