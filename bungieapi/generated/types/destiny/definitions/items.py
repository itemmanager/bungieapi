# generated by update to not change manually
import dataclasses as dt
import typing as t

from bungieapi.generated.types.destiny import (DestinyEnergyType,
                                               PlugAvailabilityMode,
                                               PlugUiStyles)
from bungieapi.generated.types.destiny.definitions.common import \
    DestinyDisplayPropertiesDefinition


@dt.dataclass(frozen=True)
class DestinyItemTierTypeDefinition:
    """'Defines the tier type of an item.

    Mostly this provides human readable properties for types like
    Common, Rare, etc... It also provides some base data for infusion
    that could be useful.
    """

    display_properties: DestinyDisplayPropertiesDefinition
    infusion_process: t.Any
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyItemTierTypeInfusionBlock:
    base_quality_transfer_ratio: float
    minimum_quality_increment: int


@dt.dataclass(frozen=True)
class DestinyDerivedItemCategoryDefinition:
    """ 'A shortcut for the fact that some items have a "Preview Vendor" - See DestinyInventoryItemDefinition.preview.previewVendorHash - that is intended to be used to show what items you can get as a result of acquiring or using this item.
    A common example of this in Destiny 1 was Eververse "Boxes," which could have many possible items. This "Preview Vendor" is not a vendor you can actually see in the game, but it defines categories and sale items for all of the possible items you could get from the Box so that the game can show them to you. We summarize that info here so that you don't have to do that Vendor lookup and aggregation manually."""

    category_description: str
    items: t.Sequence["DestinyDerivedItemDefinition"]


@dt.dataclass(frozen=True)
class DestinyDerivedItemDefinition:
    """'This is a reference to, and summary data for, a specific item that you
    can get as a result of Using or Acquiring some other Item (For example,
    this could be summary information for an Emote that you can get by opening
    an an Eververse Box) See DestinyDerivedItemCategoryDefinition for more
    information."""

    item_hash: int
    item_name: str
    item_detail: str
    item_description: str
    icon_path: str
    vendor_item_index: int


@dt.dataclass(frozen=True)
class DestinyItemPlugDefinition:
    """'If an item is a Plug, its DestinyInventoryItemDefinition.plug property
    will be populated with an instance of one of these bad boys.

    This gives information about when it can be inserted, what the
    plug's category is (and thus whether it is compatible with a
    socket... see DestinySocketTypeDefinition for information about Plug
    Categories and socket compatibility), whether it is enabled and
    other Plug info.
    """

    insertion_rules: t.Sequence["DestinyPlugRuleDefinition"]
    plug_category_identifier: str
    plug_category_hash: int
    on_action_recreate_self: bool
    insertion_material_requirement_hash: int
    preview_item_override_hash: int
    enabled_material_requirement_hash: int
    enabled_rules: t.Sequence["DestinyPlugRuleDefinition"]
    ui_plug_label: str
    plug_style: PlugUiStyles
    plug_availability: PlugAvailabilityMode
    alternate_ui_plug_label: str
    alternate_plug_style: PlugUiStyles
    is_dummy_plug: bool
    parent_item_override: t.Any
    energy_capacity: t.Any
    energy_cost: t.Any


@dt.dataclass(frozen=True)
class DestinyPlugRuleDefinition:
    """'Dictates a rule around whether the plug is enabled or insertable.

    In practice, the live Destiny data will refer to these entries by
    index. You can then look up that index in the appropriate property
    (enabledRules or insertionRules) to get the localized string for the
    failure message if it failed.
    """

    failure_message: str


@dt.dataclass(frozen=True)
class DestinyParentItemOverride:
    additional_equip_requirements_display_strings: t.Sequence[str]
    pip_icon: str


@dt.dataclass(frozen=True)
class DestinyEnergyCapacityEntry:
    """'Items can have Energy Capacity, and plugs can provide that capacity
    such as on a piece of Armor in Armor 2.0.

    This is how much "Energy" can be spent on activating plugs for this
    item.
    """

    capacity_value: int
    energy_type_hash: int
    energy_type: DestinyEnergyType


@dt.dataclass(frozen=True)
class DestinyEnergyCostEntry:
    """'Some plugs cost Energy, which is a stat on the item that can be
    increased by other plugs (that, at least in Armor 2.0, have a "masterworks-
    like" mechanic for upgrading).

    If a plug has costs, the details of that cost are defined here.
    """

    energy_cost: int
    energy_type_hash: int
    energy_type: DestinyEnergyType
