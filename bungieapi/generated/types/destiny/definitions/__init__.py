# generated by update to not change manually
import dataclasses as dt
import typing as t


@dt.dataclass(frozen=True)
class DestinyDefinition:
    """'Provides common properties for destiny definitions."""

    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyProgressionDefinition:
    """'A "Progression" in Destiny is best explained by an example.

    A Character's "Level" is a progression: it has Experience that can
    be earned, levels that can be gained, and is evaluated and displayed
    at various points in the game. A Character's "Faction Reputation" is
    also a progression for much the same reason. Progression is used by
    a variety of systems, and the definition of a Progression will
    generally only be useful if combining with live data (such as a
    character's DestinyCharacterProgressionComponent.progressions
    property, which holds that character's live Progression states).
    Fundamentally, a Progression measures your "Level" by evaluating the
    thresholds in its Steps (one step per level, except for the last
    step which can be repeated indefinitely for "Levels" that have no
    ceiling) against the total earned "progression points"/experience.
    (for simplicity purposes, we will henceforth refer to earned
    progression points as experience, though it need not be a mechanic
    that in any way resembles Experience in a traditional sense). Earned
    experience is calculated in a variety of ways, determined by the
    Progression's scope. These go from looking up a stored value to
    performing exceedingly obtuse calculations. This is why we provide
    live data in DestinyCharacterProgressionComponent.progressions, so
    you don't have to worry about those.
    """

    display_properties: "DestinyProgressionDisplayPropertiesDefinition"
    scope: "DestinyProgressionScope"
    repeat_last_step: bool
    source: str
    steps: t.Sequence["DestinyProgressionStepDefinition"]
    visible: bool
    faction_hash: int
    color: t.Any
    rank_icon: str
    reward_items: t.Sequence["DestinyProgressionRewardItemQuantity"]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyProgressionDisplayPropertiesDefinition:
    display_units_name: str
    description: str
    name: str
    icon: str
    icon_sequences: t.Sequence["DestinyIconSequenceDefinition"]
    high_res_icon: str
    has_icon: bool


@dt.dataclass(frozen=True)
class DestinyProgressionStepDefinition:
    """'This defines a single Step in a progression (which roughly equates to a
    level.

    See DestinyProgressionDefinition for caveats).
    """

    step_name: str
    display_effect_type: "DestinyProgressionStepDisplayEffect"
    progress_total: int
    reward_items: t.Sequence["DestinyItemQuantity"]
    icon: str


@dt.dataclass(frozen=True)
class DestinyInventoryItemDefinition:
    """'So much of what you see in Destiny is actually an Item used in a new
    and creative way.

    This is the definition for Items in Destiny, which started off as
    just entities that could exist in your Inventory but ended up being
    the backing data for so much more: quests, reward previews, slots,
    and subclasses. In practice, you will want to associate this data
    with "live" item data from a Bungie.Net Platform call: these
    definitions describe the item in generic, non-instanced terms: but
    an actual instance of an item can vary widely from these generic
    definitions.
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    tooltip_notifications: t.Sequence["DestinyItemTooltipNotification"]
    collectible_hash: int
    icon_watermark: str
    icon_watermark_shelved: str
    secondary_icon: str
    secondary_overlay: str
    secondary_special: str
    background_color: t.Any
    screenshot: str
    item_type_display_name: str
    flavor_text: str
    ui_item_display_style: str
    item_type_and_tier_display_name: str
    display_source: str
    tooltip_style: str
    action: t.Any
    inventory: t.Any
    set_data: t.Any
    stats: t.Any
    emblem_objective_hash: int
    equipping_block: t.Any
    translation_block: t.Any
    preview: t.Any
    quality: t.Any
    value: t.Any
    source_data: t.Any
    objectives: t.Any
    metrics: t.Any
    plug: t.Any
    gearset: t.Any
    sack: t.Any
    sockets: t.Any
    summary: t.Any
    talent_grid: t.Any
    investment_stats: t.Sequence["DestinyItemInvestmentStatDefinition"]
    perks: t.Sequence["DestinyItemPerkEntryDefinition"]
    lore_hash: int
    summary_item_hash: int
    animations: t.Sequence["DestinyAnimationReference"]
    allow_actions: bool
    links: t.Sequence["HyperlinkReference"]
    does_postmaster_pull_have_side_effects: bool
    non_transferrable: bool
    item_category_hashes: t.Sequence[int]
    special_item_type: "SpecialItemType"
    item_type: "DestinyItemType"
    item_sub_type: "DestinyItemSubType"
    class_type: "DestinyClass"
    breaker_type: "DestinyBreakerType"
    breaker_type_hash: int
    equippable: bool
    damage_type_hashes: t.Sequence[int]
    damage_types: t.Sequence["DamageType"]
    default_damage_type: "DamageType"
    default_damage_type_hash: int
    season_hash: int
    is_wrapper: bool
    trait_ids: t.Sequence[str]
    trait_hashes: t.Sequence[int]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyItemTooltipNotification:
    display_string: str
    display_style: str


@dt.dataclass(frozen=True)
class DestinyItemActionBlockDefinition:
    """'If an item can have an action performed on it (like "Dismantle"), it
    will be defined here if you care."""

    verb_name: str
    verb_description: str
    is_positive: bool
    overlay_screen_name: str
    overlay_icon: str
    required_cooldown_seconds: int
    required_items: t.Sequence["DestinyItemActionRequiredItemDefinition"]
    progression_rewards: t.Sequence["DestinyProgressionRewardDefinition"]
    action_type_label: str
    required_location: str
    required_cooldown_hash: int
    delete_on_action: bool
    consume_entire_stack: bool
    use_on_acquire: bool


@dt.dataclass(frozen=True)
class DestinyItemActionRequiredItemDefinition:
    """'The definition of an item and quantity required in a character's
    inventory in order to perform an action."""

    count: int
    item_hash: int
    delete_on_action: bool


@dt.dataclass(frozen=True)
class DestinyProgressionRewardDefinition:
    """'Inventory Items can reward progression when actions are performed on
    them.

    A common example of this in Destiny 1 was Bounties, which would
    reward Experience on your Character and the like when you completed
    the bounty. Note that this maps to a
    DestinyProgressionMappingDefinition, and *not* a
    DestinyProgressionDefinition directly. This is apparently so that
    multiple progressions can be granted progression points/experience
    at the same time.
    """

    progression_mapping_hash: int
    amount: int
    apply_throttles: bool


@dt.dataclass(frozen=True)
class DestinyProgressionMappingDefinition:
    """'Aggregations of multiple progressions.

    These are used to apply rewards to multiple progressions at once.
    They can sometimes have human readable data as well, but only
    extremely sporadically.
    """

    display_properties: t.Any
    display_units: str
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyItemInventoryBlockDefinition:
    """'If the item can exist in an inventory - the overwhelming majority of them can and do - then this is the basic properties regarding the item's relationship with the inventory."""

    stack_unique_label: str
    max_stack_size: int
    bucket_type_hash: int
    recovery_bucket_type_hash: int
    tier_type_hash: int
    is_instance_item: bool
    tier_type_name: str
    tier_type: "TierType"
    expiration_tooltip: str
    expired_in_activity_message: str
    expired_in_orbit_message: str
    suppress_expiration_when_objectives_complete: bool


@dt.dataclass(frozen=True)
class DestinyInventoryBucketDefinition:
    """'An Inventory (be it Character or Profile level) is comprised of many
    Buckets.

    An example of a bucket is "Primary Weapons", where all of the primary weapons on a character are gathered together into a single visual element in the UI: a subset of the inventory that has a limited number of slots, and in this case also has an associated Equipment Slot for equipping an item in the bucket.
    Item definitions declare what their "default" bucket is (DestinyInventoryItemDefinition.inventory.bucketTypeHash), and Item instances will tell you which bucket they are currently residing in (DestinyItemComponent.bucketHash). You can use this information along with the DestinyInventoryBucketDefinition to show these items grouped by bucket.
    You cannot transfer an item to a bucket that is not its Default without going through a Vendor's "accepted items" (DestinyVendorDefinition.acceptedItems). This is how transfer functionality like the Vault is implemented, as a feature of a Vendor. See the vendor's acceptedItems property for more details.
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    scope: "BucketScope"
    category: "BucketCategory"
    bucket_order: int
    item_count: int
    location: "ItemLocation"
    has_transfer_destination: bool
    enabled: bool
    fifo: bool
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyItemSetBlockDefinition:
    """'Primarily for Quests, this is the definition of properties related to
    the item if it is a quest and its various quest steps."""

    item_list: t.Sequence["DestinyItemSetBlockEntryDefinition"]
    require_ordered_set_item_add: bool
    set_is_featured: bool
    set_type: str
    quest_line_name: str
    quest_line_description: str
    quest_step_summary: str


@dt.dataclass(frozen=True)
class DestinyItemSetBlockEntryDefinition:
    """'Defines a particular entry in an ItemSet (AKA a particular Quest Step
    in a Quest)"""

    tracking_value: int
    item_hash: int


@dt.dataclass(frozen=True)
class DestinyItemStatBlockDefinition:
    """'Information about the item's calculated stats, with as much data as we
    can find for the stats without having an actual instance of the item.

    Note that this means the entire concept of providing these stats is
    fundamentally insufficient: we cannot predict with 100% accuracy the
    conditions under which an item can spawn, so we use various
    heuristics to attempt to simulate the conditions as accurately as
    possible. Actual stats for items in-game can and will vary, but
    these should at least be useful base points for comparison and
    display. It is also worth noting that some stats, like Magazine
    size, have further calculations performed on them by scripts in-game
    and on the game servers that BNet does not have access to. We cannot
    know how those stats are further transformed, and thus some stats
    will be inaccurate even on instances of items in BNet vs. how they
    appear in-game. This is a known limitation of our item statistics,
    without any planned fix.
    """

    disable_primary_stat_display: bool
    stat_group_hash: int
    stats: t.Mapping[str, "DestinyInventoryItemStatDefinition"]
    has_displayable_stats: bool
    primary_base_stat_hash: int


@dt.dataclass(frozen=True)
class DestinyInventoryItemStatDefinition:
    """'Defines a specific stat value on an item, and the minimum/maximum range
    that we could compute for the item based on our heuristics for how the item
    might be generated.

    Not guaranteed to match real-world instances of the item, but should
    hopefully at least be close. If it's not close, let us know on the
    Bungie API forums.
    """

    stat_hash: int
    value: int
    minimum: int
    maximum: int
    display_maximum: int


@dt.dataclass(frozen=True)
class DestinyStatDefinition:
    """'This represents a stat that's applied to a character or an item (such
    as a weapon, piece of armor, or a vehicle). An example of a stat might be
    Attack Power on a weapon. Stats go through a complex set of transformations
    before they end up being shown to the user as a number or a progress bar,
    and those transformations are fundamentally intertwined with the concept of
    a "Stat Group" (DestinyStatGroupDefinition). Items have both Stats and a
    reference to a Stat Group, and it is the Stat Group that takes the raw stat
    information and gives it both rendering metadata (such as whether to show
    it as a number or a progress bar) and the final transformation data
    (interpolation tables to turn the raw investment stat into a display stat).
    Please see DestinyStatGroupDefinition for more information on that
    transformational process. Stats are segregated from Stat Groups because
    different items and types of items can refer to the same stat, but have
    different "scales" for the stat while still having the same underlying
    value. For example, both a Shotgun and an Auto Rifle may have a "raw"
    impact stat of 50, but the Auto Rifle's Stat Group will scale that 50 down
    so that, when it is displayed, it is a smaller value relative to the
    shotgun. (this is a totally made up example, don't assume shotguns have
    naturally higher impact than auto rifles because of this)

    A final caveat is that some stats, even after this "final" transformation, go through yet another set of transformations directly in the game as a result of dynamic, stateful scripts that get run. BNet has no access to these scripts, nor any way to know which scripts get executed. As a result, the stats for an item that you see in-game - particularly for stats that are often impacted by Perks, like Magazine Size - can change dramatically from what we return on Bungie.Net. This is a known issue with no fix coming down the pipeline. Take these stats with a grain of salt.
    Stats actually go through four transformations, for those interested:
    1) "Sandbox" stat, the "most raw" form. These are pretty much useless without transformations applied, and thus are not currently returned in the API. If you really want these, we can provide them. Maybe someone could do something cool with it?
    2) "Investment" stat (the stat's value after DestinyStatDefinition's interpolation tables and aggregation logic is applied to the "Sandbox" stat value)
    3) "Display" stat (the stat's base UI-visible value after DestinyStatGroupDefinition's interpolation tables are applied to the Investment Stat value. For most stats, this is what is displayed.)
    4) Underlying in-game stat (the stat's actual value according to the game, after the game runs dynamic scripts based on the game and character's state. This is the final transformation that BNet does not have access to. For most stats, this is not actually displayed to the user, with the exception of Magazine Size which is then piped back to the UI for display in-game, but not to BNet.)
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    aggregation_type: "DestinyStatAggregationType"
    has_computed_block: bool
    stat_category: "DestinyStatCategory"
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyStatGroupDefinition:
    """'When an inventory item (DestinyInventoryItemDefinition) has Stats (such
    as Attack Power), the item will refer to a Stat Group.

    This definition enumerates the properties used to transform the
    item's "Investment" stats into "Display" stats. See
    DestinyStatDefinition's documentation for information about the
    transformation of Stats, and the meaning of an Investment vs. a
    Display stat. If you don't want to do these calculations on your
    own, fear not: pulling live data from the BNet endpoints will return
    display stat values pre-computed and ready for you to use. I highly
    recommend this approach, saves a lot of time and also accounts for
    certain stat modifiers that can't easily be accounted for without
    live data (such as stat modifiers on Talent Grids and Socket Plugs)
    """

    maximum_value: int
    ui_position: int
    scaled_stats: t.Sequence["DestinyStatDisplayDefinition"]
    overrides: t.Mapping[str, "DestinyStatOverrideDefinition"]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyStatDisplayDefinition:
    """'Describes the way that an Item Stat (see DestinyStatDefinition) is
    transformed using the DestinyStatGroupDefinition related to that item.

    See both of the aforementioned definitions for more information
    about the stages of stat transformation. This represents the
    transformation of a stat into a "Display" stat (the closest value
    that BNet can get to the in-game display value of the stat)
    """

    stat_hash: int
    maximum_value: int
    display_as_numeric: bool
    display_interpolation: t.Sequence["InterpolationPoint"]


@dt.dataclass(frozen=True)
class DestinyStatOverrideDefinition:
    """'Stat Groups (DestinyStatGroupDefinition) has the ability to override
    the localized text associated with stats that are to be shown on the items
    with which they are associated.

    This defines a specific overridden stat. You could theoretically
    check these before rendering your stat UI, and for each stat that
    has an override show these displayProperties instead of those on the
    DestinyStatDefinition. Or you could be like us, and skip that for
    now because the game has yet to actually use this feature. But know
    that it's here, waiting for a resilliant young designer to take up
    the mantle and make us all look foolish by showing the wrong name
    for stats. Note that, if this gets used, the override will apply
    only to items using the overriding Stat Group. Other items will
    still show the default stat's name/description.
    """

    stat_hash: int
    display_properties: t.Any


@dt.dataclass(frozen=True)
class DestinyEquippingBlockDefinition:
    """'Items that can be equipped define this block.

    It contains information we need to understand how and when the item
    can be equipped.
    """

    gearset_item_hash: int
    unique_label: str
    unique_label_hash: int
    equipment_slot_type_hash: int
    attributes: "EquippingItemBlockAttributes"
    ammo_type: "DestinyAmmunitionType"
    display_strings: t.Sequence[str]


@dt.dataclass(frozen=True)
class DestinyEquipmentSlotDefinition:
    """'Characters can not only have Inventory buckets (containers of items
    that are generally matched by their type or functionality), they can also
    have Equipment Slots.

    The Equipment Slot is an indicator that the related bucket can have
    instanced items equipped on the character. For instance, the Primary
    Weapon bucket has an Equipment Slot that determines whether you can
    equip primary weapons, and holds the association between its slot
    and the inventory bucket from which it can have items equipped. An
    Equipment Slot must have a related Inventory Bucket, but not all
    inventory buckets must have Equipment Slots.
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    equipment_category_hash: int
    bucket_type_hash: int
    apply_custom_art_dyes: bool
    art_dye_channels: t.Sequence["DestinyArtDyeReference"]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyArtDyeReference:
    art_dye_channel_hash: int


@dt.dataclass(frozen=True)
class DestinyItemTranslationBlockDefinition:
    """'This Block defines the rendering data associated with the item, if
    any."""

    weapon_pattern_identifier: str
    weapon_pattern_hash: int
    default_dyes: t.Sequence["DyeReference"]
    locked_dyes: t.Sequence["DyeReference"]
    custom_dyes: t.Sequence["DyeReference"]
    arrangements: t.Sequence["DestinyGearArtArrangementReference"]
    has_geometry: bool


@dt.dataclass(frozen=True)
class DestinyGearArtArrangementReference:
    class_hash: int
    art_arrangement_hash: int


@dt.dataclass(frozen=True)
class DestinyItemPreviewBlockDefinition:
    """'Items like Sacks or Boxes can have items that it shows in-game when you
    view details that represent the items you can obtain if you use or acquire
    the item.

    This defines those categories, and gives some insights into that
    data's source.
    """

    screen_style: str
    preview_vendor_hash: int
    artifact_hash: int
    preview_action_string: str
    derived_item_categories: t.Sequence["DestinyDerivedItemCategoryDefinition"]


@dt.dataclass(frozen=True)
class DestinyVendorDefinition:
    """'These are the definitions for Vendors.

    In Destiny, a Vendor can be a lot of things - some things that you wouldn't expect, and some things that you don't even see directly in the game. Vendors are the Dolly Levi of the Destiny universe.
    - Traditional Vendors as you see in game: people who you come up to and who give you quests, rewards, or who you can buy things from.
    - Kiosks/Collections, which are really just Vendors that don't charge currency (or charge some pittance of a currency) and whose gating for purchases revolves more around your character's state.
    - Previews for rewards or the contents of sacks. These are implemented as Vendors, where you can't actually purchase from them but the items that they have for sale and the categories of sale items reflect the rewards or contents of the sack. This is so that the game could reuse the existing Vendor display UI for rewards and save a bunch of wheel reinvention.
    - Item Transfer capabilities, like the Vault and Postmaster. Vendors can have "acceptedItem" buckets that determine the source and destination buckets for transfers. When you interact with such a vendor, these buckets are what gets shown in the UI instead of any items that the Vendor would have for sale. Yep, the Vault is a vendor.
    It is pretty much guaranteed that they'll be used for even more features in the future. They have come to be seen more as generic categorized containers for items than "vendors" in a traditional sense, for better or worse.
    Where possible and time allows, we'll attempt to split those out into their own more digestible derived "Definitions": but often time does not allow that, as you can see from the above ways that vendors are used which we never split off from Vendor Definitions externally.
    Since Vendors are so many things to so many parts of the game, the definition is understandably complex. You will want to combine this data with live Vendor information from the API when it is available.
    """

    display_properties: "DestinyVendorDisplayPropertiesDefinition"
    vendor_progression_type: "DestinyVendorProgressionType"
    buy_string: str
    sell_string: str
    display_item_hash: int
    inhibit_buying: bool
    inhibit_selling: bool
    faction_hash: int
    reset_interval_minutes: int
    reset_offset_minutes: int
    failure_strings: t.Sequence[str]
    unlock_ranges: t.Sequence["DateRange"]
    vendor_identifier: str
    vendor_portrait: str
    vendor_banner: str
    enabled: bool
    visible: bool
    vendor_subcategory_identifier: str
    consolidate_categories: bool
    actions: t.Sequence["DestinyVendorActionDefinition"]
    categories: t.Sequence["DestinyVendorCategoryEntryDefinition"]
    original_categories: t.Sequence["DestinyVendorCategoryEntryDefinition"]
    display_categories: t.Sequence["DestinyDisplayCategoryDefinition"]
    interactions: t.Sequence["DestinyVendorInteractionDefinition"]
    inventory_flyouts: t.Sequence["DestinyVendorInventoryFlyoutDefinition"]
    item_list: t.Sequence["DestinyVendorItemDefinition"]
    services: t.Sequence["DestinyVendorServiceDefinition"]
    accepted_items: t.Sequence["DestinyVendorAcceptedItemDefinition"]
    return_with_vendor_request: bool
    locations: t.Sequence["DestinyVendorLocationDefinition"]
    groups: t.Sequence["DestinyVendorGroupReference"]
    ignore_sale_item_hashes: t.Sequence[int]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyVendorDisplayPropertiesDefinition:
    large_icon: str
    subtitle: str
    original_icon: str
    requirements_display: t.Sequence["DestinyVendorRequirementDisplayEntryDefinition"]
    small_transparent_icon: str
    map_icon: str
    large_transparent_icon: str
    description: str
    name: str
    icon: str
    icon_sequences: t.Sequence["DestinyIconSequenceDefinition"]
    high_res_icon: str
    has_icon: bool


@dt.dataclass(frozen=True)
class DestinyVendorRequirementDisplayEntryDefinition:
    """'The localized properties of the requirementsDisplay, allowing
    information about the requirement or item being featured to be seen."""

    icon: str
    name: str
    source: str
    type: str


@dt.dataclass(frozen=True)
class DestinyVendorActionDefinition:
    """'If a vendor can ever end up performing actions, these are the
    properties that will be related to those actions.

    I'm not going to bother documenting this yet, as it is unused and
    unclear if it will ever be used... but in case it is ever populated
    and someone finds it useful, it is defined here.
    """

    description: str
    execute_seconds: int
    icon: str
    name: str
    verb: str
    is_positive: bool
    action_id: str
    action_hash: int
    auto_perform_action: bool


@dt.dataclass(frozen=True)
class DestinyVendorCategoryEntryDefinition:
    """'This is the definition for a single Vendor Category, into which Sale
    Items are grouped."""

    category_index: int
    sort_value: int
    category_hash: int
    quantity_available: int
    show_unavailable_items: bool
    hide_if_no_currency: bool
    hide_from_regular_purchase: bool
    buy_string_override: str
    disabled_description: str
    display_title: str
    overlay: t.Any
    vendor_item_indexes: t.Sequence[int]
    is_preview: bool
    is_display_only: bool
    reset_interval_minutes_override: int
    reset_offset_minutes_override: int


@dt.dataclass(frozen=True)
class DestinyVendorCategoryOverlayDefinition:
    """'The details of an overlay prompt to show to a user.

    They are all fairly self-explanatory localized strings that can be
    shown.
    """

    choice_description: str
    description: str
    icon: str
    title: str
    currency_item_hash: int


@dt.dataclass(frozen=True)
class DestinyDisplayCategoryDefinition:
    """'Display Categories are different from "categories" in that these are
    specifically for visual grouping and display of categories in Vendor UI.

    The "categories" structure is for validation of the contained items,
    and can be categorized entirely separately from "Display
    Categories", there need be and often will be no meaningful
    relationship between the two.
    """

    index: int
    identifier: str
    display_category_hash: int
    display_properties: "DestinyDisplayPropertiesDefinition"
    display_in_banner: bool
    progression_hash: int
    sort_order: "VendorDisplayCategorySortOrder"
    display_style_hash: int
    display_style_identifier: str


@dt.dataclass(frozen=True)
class DestinyVendorInteractionDefinition:
    """'A Vendor Interaction is a dialog shown by the vendor other than sale
    items or transfer screens.

    The vendor is showing you something, and asking you to reply to it
    by choosing an option or reward.
    """

    interaction_index: int
    replies: t.Sequence["DestinyVendorInteractionReplyDefinition"]
    vendor_category_index: int
    questline_item_hash: int
    sack_interaction_list: t.Sequence["DestinyVendorInteractionSackEntryDefinition"]
    ui_interaction_type: int
    interaction_type: "VendorInteractionType"
    reward_block_label: str
    reward_vendor_category_index: int
    flavor_line_one: str
    flavor_line_two: str
    header_display_properties: t.Any
    instructions: str


@dt.dataclass(frozen=True)
class DestinyVendorInteractionReplyDefinition:
    """'When the interaction is replied to, Reward sites will fire and items
    potentially selected based on whether the given unlock expression is TRUE.

    You can potentially choose one from multiple replies when replying
    to an interaction: this is how you get either/or rewards from
    vendors.
    """

    item_rewards_selection: "DestinyVendorInteractionRewardSelection"
    reply: str
    reply_type: "DestinyVendorReplyType"


@dt.dataclass(frozen=True)
class DestinyVendorInteractionSackEntryDefinition:
    """'Compare this sackType to the sack identifier in the
    DestinyInventoryItemDefinition.vendorSackType property of items.

    If they match, show this sack with this interaction.
    """

    sack_type: int


@dt.dataclass(frozen=True)
class DestinyVendorInventoryFlyoutDefinition:
    """'The definition for an "inventory flyout": a UI screen where we show you
    part of an otherwise hidden vendor inventory: like the Vault inventory
    buckets."""

    locked_description: str
    display_properties: t.Any
    buckets: t.Sequence["DestinyVendorInventoryFlyoutBucketDefinition"]
    flyout_id: int
    suppress_newness: bool
    equipment_slot_hash: int


@dt.dataclass(frozen=True)
class DestinyVendorInventoryFlyoutBucketDefinition:
    """'Information about a single inventory bucket in a vendor flyout UI and
    how it is shown."""

    collapsible: bool
    inventory_bucket_hash: int
    sort_items_by: "DestinyItemSortType"


@dt.dataclass(frozen=True)
class DestinyVendorItemDefinition:
    """'This represents an item being sold by the vendor."""

    vendor_item_index: int
    item_hash: int
    quantity: int
    failure_indexes: t.Sequence[int]
    currencies: t.Sequence["DestinyVendorItemQuantity"]
    refund_policy: "DestinyVendorItemRefundPolicy"
    refund_time_limit: int
    creation_levels: t.Sequence["DestinyItemCreationEntryLevelDefinition"]
    display_category_index: int
    category_index: int
    original_category_index: int
    minimum_level: int
    maximum_level: int
    action: t.Any
    display_category: str
    inventory_bucket_hash: int
    visibility_scope: "DestinyGatingScope"
    purchasable_scope: "DestinyGatingScope"
    exclusivity: "BungieMembershipType"
    is_offer: bool
    is_crm: bool
    sort_value: int
    expiration_tooltip: str
    redirect_to_sale_indexes: t.Sequence[int]
    socket_overrides: t.Sequence["DestinyVendorItemSocketOverride"]
    unpurchasable: bool


@dt.dataclass(frozen=True)
class DestinyVendorItemQuantity:
    """'In addition to item quantity information for vendor prices, this also
    has any optional information that may exist about how the item's quantity
    can be modified.

    (unfortunately not information that is able to be read outside of
    the BNet servers, but it's there)
    """

    item_hash: int
    item_instance_id: int
    quantity: int
    has_conditional_visibility: bool


@dt.dataclass(frozen=True)
class DestinyItemCreationEntryLevelDefinition:
    """'An overly complicated wrapper for the item level at which the item
    should spawn."""

    level: int


@dt.dataclass(frozen=True)
class DestinyVendorSaleItemActionBlockDefinition:
    """'Not terribly useful, some basic cooldown interaction info."""

    execute_seconds: float
    is_positive: bool


@dt.dataclass(frozen=True)
class DestinyVendorItemSocketOverride:
    """'The information for how the vendor purchase should override a given
    socket with custom plug data."""

    single_item_hash: int
    randomized_options_count: int
    socket_type_hash: int


@dt.dataclass(frozen=True)
class DestinyVendorServiceDefinition:
    """'When a vendor provides services, this is the localized name of those
    services."""

    name: str


@dt.dataclass(frozen=True)
class DestinyVendorAcceptedItemDefinition:
    """'If you ever wondered how the Vault works, here it is.

    The Vault is merely a set of inventory buckets that exist on your
    Profile/Account level. When you transfer items in the Vault, the
    game is using the Vault Vendor's
    DestinyVendorAcceptedItemDefinitions to see where the appropriate
    destination bucket is for the source bucket from whence your item is
    moving. If it finds such an entry, it transfers the item to the
    other bucket. The mechanics for Postmaster works similarly, which is
    also a vendor. All driven by Accepted Items.
    """

    accepted_inventory_bucket_hash: int
    destination_inventory_bucket_hash: int


@dt.dataclass(frozen=True)
class DestinyDestinationDefinition:
    """'On to one of the more confusing subjects of the API.

    What is a Destination, and what is the relationship between it,
    Activities, Locations, and Places? A "Destination" is a specific
    region/city/area of a larger "Place". For instance, a Place might be
    Earth where a Destination might be Bellevue, Washington. (Please,
    pick a more interesting destination if you come to visit Earth).
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    place_hash: int
    default_freeroam_activity_hash: int
    activity_graph_entries: t.Sequence["DestinyActivityGraphListEntryDefinition"]
    bubble_settings: t.Sequence["DestinyDestinationBubbleSettingDefinition"]
    bubbles: t.Sequence["DestinyBubbleDefinition"]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyActivityGraphListEntryDefinition:
    """'Destinations and Activities may have default Activity Graphs that
    should be shown when you bring up the Director and are playing in either.

    This contract defines the graph referred to and the gating for when
    it is relevant.
    """

    activity_graph_hash: int


@dt.dataclass(frozen=True)
class DestinyActivityDefinition:
    """'The static data about Activities in Destiny 2.

    Note that an Activity must be combined with an ActivityMode to know - from a Gameplay perspective - what the user is "Playing".
    In most PvE activities, this is fairly straightforward. A Story Activity can only be played in the Story Activity Mode.
    However, in PvP activities, the Activity alone only tells you the map being played, or the Playlist that the user chose to enter. You'll need to know the Activity Mode they're playing to know that they're playing Mode X on Map Y.
    Activity Definitions tell a great deal of information about what *could* be relevant to a user: what rewards they can earn, what challenges could be performed, what modifiers could be applied. To figure out which of these properties is actually live, you'll need to combine the definition with "Live" data from one of the Destiny endpoints.
    Activities also have Activity Types, but unfortunately in Destiny 2 these are even less reliable of a source of information than they were in Destiny 1. I will be looking into ways to provide more reliable sources for type information as time goes on, but for now we're going to have to deal with the limitations. See DestinyActivityTypeDefinition for more information.
    """

    display_properties: t.Any
    original_display_properties: t.Any
    selection_screen_display_properties: t.Any
    release_icon: str
    release_time: int
    activity_light_level: int
    destination_hash: int
    place_hash: int
    activity_type_hash: int
    tier: int
    pgcr_image: str
    rewards: t.Sequence["DestinyActivityRewardDefinition"]
    modifiers: t.Sequence["DestinyActivityModifierReferenceDefinition"]
    is_playlist: bool
    challenges: t.Sequence["DestinyActivityChallengeDefinition"]
    optional_unlock_strings: t.Sequence["DestinyActivityUnlockStringDefinition"]
    playlist_items: t.Sequence["DestinyActivityPlaylistItemDefinition"]
    activity_graph_list: t.Sequence["DestinyActivityGraphListEntryDefinition"]
    matchmaking: t.Any
    guided_game: t.Any
    direct_activity_mode_hash: int
    direct_activity_mode_type: int
    loadouts: t.Sequence["DestinyActivityLoadoutRequirementSet"]
    activity_mode_hashes: t.Sequence[int]
    activity_mode_types: t.Sequence["DestinyActivityModeType"]
    is_pv_p: bool
    insertion_points: t.Sequence["DestinyActivityInsertionPointDefinition"]
    activity_location_mappings: t.Sequence["DestinyEnvironmentLocationMapping"]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyActivityRewardDefinition:
    """'Activities can refer to one or more sets of tooltip-friendly reward
    data.

    These are the definitions for those tooltip friendly rewards.
    """

    reward_text: str
    reward_items: t.Sequence["DestinyItemQuantity"]


@dt.dataclass(frozen=True)
class DestinyActivityModifierReferenceDefinition:
    """'A reference to an Activity Modifier from another entity, such as an
    Activity (for now, just Activities).

    This defines some
    """

    activity_modifier_hash: int


@dt.dataclass(frozen=True)
class DestinyActivityChallengeDefinition:
    """'Represents a reference to a Challenge, which for now is just an
    Objective."""

    objective_hash: int
    dummy_rewards: t.Sequence["DestinyItemQuantity"]


@dt.dataclass(frozen=True)
class DestinyObjectiveDefinition:
    """'Defines an "Objective". An objective is a specific task you should
    accomplish in the game. These are referred to by:

    - Quest Steps (which are DestinyInventoryItemDefinition entities with Objectives)
    - Challenges (which are Objectives defined on an DestinyActivityDefintion)
    - Milestones (which refer to Objectives that are defined on both Quest Steps and Activities)
    - Anything else that the designers decide to do later.
    Objectives have progress, a notion of having been Completed, human readable data describing the task to be accomplished, and a lot of optional tack-on data that can enhance the information provided about the task.
    """

    display_properties: t.Any
    completion_value: int
    scope: "DestinyGatingScope"
    location_hash: int
    allow_negative_value: bool
    allow_value_change_when_completed: bool
    is_counting_downward: bool
    value_style: "DestinyUnlockValueUIStyle"
    progress_description: str
    perks: t.Any
    stats: t.Any
    minimum_visibility_threshold: int
    allow_overcompletion: bool
    show_value_on_complete: bool
    completed_value_style: "DestinyUnlockValueUIStyle"
    in_progress_value_style: "DestinyUnlockValueUIStyle"
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyObjectivePerkEntryDefinition:
    """'Defines the conditions under which an intrinsic perk is applied while
    participating in an Objective.

    These perks will generally not be benefit-granting perks, but rather
    a perk that modifies gameplay in some interesting way.
    """

    perk_hash: int
    style: "DestinyObjectiveGrantStyle"


@dt.dataclass(frozen=True)
class DestinySandboxPerkDefinition:
    """'Perks are modifiers to a character or item that can be applied
    situationally.

    - Perks determine a weapons' damage type.
    - Perks put the Mods in Modifiers (they are literally the entity that bestows the Sandbox benefit for whatever fluff text about the modifier in the Socket, Plug or Talent Node)
    - Perks are applied for unique alterations of state in Objectives
    Anyways, I'm sure you can see why perks are so interesting.
    What Perks often don't have is human readable information, so we attempt to reverse engineer that by pulling that data from places that uniquely refer to these perks: namely, Talent Nodes and Plugs. That only gives us a subset of perks that are human readable, but those perks are the ones people generally care about anyways. The others are left as a mystery, their true purpose mostly unknown and undocumented.
    """

    display_properties: t.Any
    perk_identifier: str
    is_displayable: bool
    damage_type: "DamageType"
    damage_type_hash: int
    perk_groups: t.Any
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyTalentNodeStepGroups:
    """'These properties are an attempt to categorize talent node steps by
    certain common properties.

    See the related enumerations for the type of properties being
    categorized.
    """

    weapon_performance: "DestinyTalentNodeStepWeaponPerformances"
    impact_effects: "DestinyTalentNodeStepImpactEffects"
    guardian_attributes: "DestinyTalentNodeStepGuardianAttributes"
    light_abilities: "DestinyTalentNodeStepLightAbilities"
    damage_types: "DestinyTalentNodeStepDamageTypes"


DestinyTalentNodeStepWeaponPerformances = t.Any
DestinyTalentNodeStepImpactEffects = t.Any
DestinyTalentNodeStepGuardianAttributes = t.Any
DestinyTalentNodeStepLightAbilities = t.Any
DestinyTalentNodeStepDamageTypes = t.Any


@dt.dataclass(frozen=True)
class DestinyObjectiveStatEntryDefinition:
    """'Defines the conditions under which stat modifications will be applied
    to a Character while participating in an objective."""

    stat: t.Any
    style: "DestinyObjectiveGrantStyle"


@dt.dataclass(frozen=True)
class DestinyItemInvestmentStatDefinition:
    """'Represents a "raw" investment stat, before calculated stats are
    calculated and before any DestinyStatGroupDefinition is applied to
    transform the stat into something closer to what you see in-game.

    Because these won't match what you see in-game, consider carefully
    whether you really want to use these stats. I have left them in case
    someone can do something useful or interesting with the pre-
    processed statistics.
    """

    stat_type_hash: int
    value: int
    is_conditionally_active: bool


@dt.dataclass(frozen=True)
class DestinyLocationDefinition:
    """'A "Location" is a sort of shortcut for referring to a specific
    combination of Activity, Destination, Place, and even Bubble or NavPoint
    within a space.

    Most of this data isn't intrinsically useful to us, but Objectives
    refer to locations, and through that we can at least infer the
    Activity, Destination, and Place being referred to by the Objective.
    """

    vendor_hash: int
    location_releases: t.Sequence["DestinyLocationReleaseDefinition"]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyLocationReleaseDefinition:
    """'A specific "spot" referred to by a location.

    Only one of these can be active at a time for a given Location.
    """

    display_properties: t.Any
    small_transparent_icon: str
    map_icon: str
    large_transparent_icon: str
    spawn_point: int
    destination_hash: int
    activity_hash: int
    activity_graph_hash: int
    activity_graph_node_hash: int
    activity_bubble_name: int
    activity_path_bundle: int
    activity_path_destination: int
    nav_point_type: "DestinyActivityNavPointType"
    world_position: t.Sequence[int]


@dt.dataclass(frozen=True)
class DestinyActivityUnlockStringDefinition:
    """'Represents a status string that could be conditionally displayed about
    an activity.

    Note that externally, you can only see the strings themselves.
    Internally we combine this information with server state to
    determine which strings should be shown.
    """

    display_string: str


@dt.dataclass(frozen=True)
class DestinyActivityPlaylistItemDefinition:
    """'If the activity is a playlist, this is the definition for a specific
    entry in the playlist: a single possible combination of Activity and
    Activity Mode that can be chosen."""

    activity_hash: int
    direct_activity_mode_hash: int
    direct_activity_mode_type: int
    activity_mode_hashes: t.Sequence[int]
    activity_mode_types: t.Sequence["DestinyActivityModeType"]


@dt.dataclass(frozen=True)
class DestinyActivityModeDefinition:
    """'This definition represents an "Activity Mode" as it exists in the
    Historical Stats endpoints. An individual Activity Mode represents a
    collection of activities that are played in a certain way. For example,
    Nightfall Strikes are part of a "Nightfall" activity mode, and any
    activities played as the PVP mode "Clash" are part of the "Clash activity
    mode.

    Activity modes are nested under each other in a hierarchy, so that if you ask for - for example - "AllPvP", you will get any PVP activities that the user has played, regardless of what specific PVP mode was being played.
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    pgcr_image: str
    mode_type: "DestinyActivityModeType"
    activity_mode_category: "DestinyActivityModeCategory"
    is_team_based: bool
    is_aggregate_mode: bool
    parent_hashes: t.Sequence[int]
    friendly_name: str
    activity_mode_mappings: t.Mapping[str, "DestinyActivityModeType"]
    display: bool
    order: int
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyActivityMatchmakingBlockDefinition:
    """'Information about matchmaking and party size for the activity."""

    is_matchmade: bool
    min_party: int
    max_party: int
    max_players: int
    requires_guardian_oath: bool


@dt.dataclass(frozen=True)
class DestinyActivityGuidedBlockDefinition:
    """'Guided Game information for this activity."""

    guided_max_lobby_size: int
    guided_min_lobby_size: int
    guided_disband_count: int


@dt.dataclass(frozen=True)
class DestinyActivityLoadoutRequirementSet:
    requirements: t.Sequence["DestinyActivityLoadoutRequirement"]


@dt.dataclass(frozen=True)
class DestinyActivityLoadoutRequirement:
    equipment_slot_hash: int
    allowed_equipped_item_hashes: t.Sequence[int]
    allowed_weapon_sub_types: t.Sequence["DestinyItemSubType"]


@dt.dataclass(frozen=True)
class DestinyActivityInsertionPointDefinition:
    """'A point of entry into an activity, gated by an unlock flag and with
    some more-or-less useless (for our purposes) phase information.

    I'm including it in case we end up being able to bolt more useful information onto it in the future.
    UPDATE: Turns out this information isn't actually useless, and is in fact actually useful for people. Who would have thought? We still don't have localized info for it, but at least this will help people when they're looking at phase indexes in stats data, or when they want to know what phases have been completed on a weekly achievement.
    """

    phase_hash: int


@dt.dataclass(frozen=True)
class DestinyPlaceDefinition:
    """'Okay, so Activities (DestinyActivityDefinition) take place in
    Destinations (DestinyDestinationDefinition).

    Destinations are part of larger locations known as Places (you're
    reading its documentation right now). Places are more on the
    planetary scale, like "Earth" and "Your Mom."
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyActivityTypeDefinition:
    """'The definition for an Activity Type.

    In Destiny 2, an Activity Type represents a conceptual
    categorization of Activities. These are most commonly used in the
    game for the subtitle under Activities, but BNet uses them
    extensively to identify and group activities by their common
    properties. Unfortunately, there has been a movement away from
    providing the richer data in Destiny 2 that we used to get in
    Destiny 1 for Activity Types. For instance, Nightfalls are grouped
    under the same Activity Type as regular Strikes. For this reason,
    BNet will eventually migrate toward Activity Modes as a better
    indicator of activity category. But for the time being, it is still
    referred to in many places across our codebase.
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyUnlockExpressionDefinition:
    """'Where the sausage gets made.

    Unlock Expressions are the foundation of the game's gating mechanics
    and investment-related restrictions. They can test Unlock Flags and
    Unlock Values for certain states, using a sufficient amount of
    logical operators such that unlock expressions are effectively
    Turing complete. Use UnlockExpressionParser to evaluate expressions
    using an IUnlockContext parsed from Babel.
    """

    scope: "DestinyGatingScope"


@dt.dataclass(frozen=True)
class DestinyDestinationBubbleSettingDefinition:
    """'Human readable data about the bubble. Combine with DestinyBubbleDefinition - see DestinyDestinationDefinition.bubbleSettings for more information.
    DEPRECATED - Just use bubbles."""

    display_properties: "DestinyDisplayPropertiesDefinition"


@dt.dataclass(frozen=True)
class DestinyBubbleDefinition:
    """'Basic identifying data about the bubble.

    Combine with DestinyDestinationBubbleSettingDefinition - see DestinyDestinationDefinition.bubbleSettings for more information.
    """

    hash: int
    display_properties: t.Any


@dt.dataclass(frozen=True)
class DestinyVendorGroupReference:
    vendor_group_hash: int


@dt.dataclass(frozen=True)
class DestinyVendorGroupDefinition:
    """'BNet attempts to group vendors into similar collections.

    These groups aren't technically game canonical, but they are helpful
    for filtering vendors or showing them organized into a clean view on
    a webpage or app. These definitions represent the groups we've
    built. Unlike in Destiny 1, a Vendors' group may change dynamically
    as the game state changes: thus, you will want to check
    DestinyVendorComponent responses to find a vendor's currently active
    Group (if you care). Using this will let you group your vendors in
    your UI in a similar manner to how we will do grouping in the
    Companion.
    """

    order: int
    category_name: str
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyFactionDefinition:
    """'These definitions represent Factions in the game.

    Factions have ended up unilaterally being related to Vendors that
    represent them, but that need not necessarily be the case. A Faction
    is really just an entity that has a related progression for which a
    character can gain experience. In Destiny 1, Dead Orbit was an
    example of a Faction: there happens to be a Vendor that represents
    Dead Orbit (and indeed, DestinyVendorDefinition.factionHash defines
    to this relationship), but Dead Orbit could theoretically exist
    without the Vendor that provides rewards.
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    progression_hash: int
    token_values: t.Mapping[str, int]
    reward_item_hash: int
    reward_vendor_hash: int
    vendors: t.Sequence["DestinyFactionVendorDefinition"]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyFactionVendorDefinition:
    """'These definitions represent faction vendors at different points in the
    game.

    A single faction may contain multiple vendors, or the same vendor
    available at two different locations.
    """

    vendor_hash: int
    destination_hash: int
    background_image_path: str


@dt.dataclass(frozen=True)
class DestinyItemQualityBlockDefinition:
    """'An item's "Quality" determines its calculated stats.

    The Level at which the item spawns is combined with its
    "qualityLevel" along with some additional calculations to determine
    the value of those stats. In Destiny 2, most items don't have
    default item levels and quality, making this property less useful:
    these apparently are almost always determined by the complex
    mechanisms of the Reward system rather than statically. They are
    still provided here in case they are still useful for people. This
    also contains some information about Infusion.
    """

    item_levels: t.Sequence[int]
    quality_level: int
    infusion_category_name: str
    infusion_category_hash: int
    infusion_category_hashes: t.Sequence[int]
    progression_level_requirement_hash: int
    current_version: int
    versions: t.Sequence["DestinyItemVersionDefinition"]
    display_version_watermark_icons: t.Sequence[str]


@dt.dataclass(frozen=True)
class DestinyItemVersionDefinition:
    """'The version definition currently just holds a reference to the power
    cap."""

    power_cap_hash: int


@dt.dataclass(frozen=True)
class DestinyItemValueBlockDefinition:
    """'This defines an item's "Value".

    Unfortunately, this appears to be used in different ways depending
    on the way that the item itself is used. For items being sold at a
    Vendor, this is the default "sale price" of the item. These days,
    the vendor itself almost always sets the price, but it still
    possible for the price to fall back to this value. For quests, it is
    a preview of rewards you can gain by completing the quest. For dummy
    items, if the itemValue refers to an Emblem, it is the emblem that
    should be shown as the reward. (jeez louise) It will likely be used
    in a number of other ways in the future, it appears to be a bucket
    where they put arbitrary items and quantities into the item.
    """

    item_value: t.Sequence["DestinyItemQuantity"]
    value_description: str


@dt.dataclass(frozen=True)
class DestinyItemSourceBlockDefinition:
    """'Data about an item's "sources": ways that the item can be obtained."""

    source_hashes: t.Sequence[int]
    sources: t.Sequence["DestinyItemSourceDefinition"]
    exclusive: "BungieMembershipType"
    vendor_sources: t.Sequence["DestinyItemVendorSourceReference"]


@dt.dataclass(frozen=True)
class DestinyRewardSourceDefinition:
    """'Represents a heuristically-determined "item source" according to
    Bungie.net.

    These item sources are non-canonical: we apply a combination of
    special configuration and often-fragile heuristics to attempt to
    discern whether an item should be part of a given "source," but we
    have known cases of false positives and negatives due to our
    imperfect heuristics. Still, they provide a decent approximation for
    people trying to figure out how an item can be obtained.
    DestinyInventoryItemDefinition refers to sources in the
    sourceDatas.sourceHashes property for all sources we determined the
    item could spawn from. An example in Destiny 1 of a Source would be
    "Nightfall". If an item has the "Nightfall" source associated with
    it, it's extremely likely that you can earn that item while playing
    Nightfall, either during play or as an after-completion reward.
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    category: "DestinyRewardSourceCategory"
    hash: int
    index: int
    redacted: bool


DestinyRewardSourceCategory = t.Any


@dt.dataclass(frozen=True)
class DestinyItemVendorSourceReference:
    """'Represents that a vendor could sell this item, and provides a quick
    link to that vendor and sale item.

    Note that we do not and cannot make a guarantee that the vendor will
    ever *actually* sell this item, only that the Vendor has a
    definition that indicates it *could* be sold. Note also that a
    vendor may sell the same item in multiple "ways", which means there
    may be multiple vendorItemIndexes for a single Vendor hash.
    """

    vendor_hash: int
    vendor_item_indexes: t.Sequence[int]


@dt.dataclass(frozen=True)
class DestinyItemObjectiveBlockDefinition:
    """'An item can have objectives on it.

    In practice, these are the exclusive purview of "Quest Step" items:
    DestinyInventoryItemDefinitions that represent a specific step in a
    Quest. Quest steps have 1:M objectives that we end up processing and
    returning in live data as DestinyQuestStatus data, and other useful
    information.
    """

    objective_hashes: t.Sequence[int]
    display_activity_hashes: t.Sequence[int]
    require_full_objective_completion: bool
    questline_item_hash: int
    narrative: str
    objective_verb_name: str
    quest_type_identifier: str
    quest_type_hash: int
    per_objective_display_properties: t.Sequence["DestinyObjectiveDisplayProperties"]
    display_as_stat_tracker: bool


@dt.dataclass(frozen=True)
class DestinyObjectiveDisplayProperties:
    activity_hash: int
    display_on_item_preview_screen: bool


@dt.dataclass(frozen=True)
class DestinyItemMetricBlockDefinition:
    """'The metrics available for display and selection on an item."""

    available_metric_category_node_hashes: t.Sequence[int]


@dt.dataclass(frozen=True)
class DestinyMaterialRequirementSetDefinition:
    """'Represent a set of material requirements: Items that either need to be
    owned or need to be consumed in order to perform an action.

    A variety of other entities refer to these as gatekeepers and
    payments for actions that can be performed in game.
    """

    materials: t.Sequence["DestinyMaterialRequirement"]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyMaterialRequirement:
    """'Many actions relating to items require you to expend materials: - Activating a talent node - Inserting a plug into a socket The items will refer to material requirements by a materialRequirementsHash in these cases, and this is the definition for those requirements in terms of the item required, how much of it is required and other interesting info. This is one of the rare/strange times where a single contract class is used both in definitions *and* in live data response contracts. I'm not sure yet whether I regret that."""

    item_hash: int
    delete_on_action: bool
    count: int
    omit_from_requirements: bool


@dt.dataclass(frozen=True)
class DestinyUnlockValueDefinition:
    """'An Unlock Value is an internal integer value, stored on the server and
    used in a variety of ways, most frequently for the gating/requirement
    checks that the game performs across all of its main features.

    They can also be used as the storage data for mapped Progressions,
    Objectives, and other features that require storage of variable
    numeric values.
    """

    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyGenderDefinition:
    """'Gender is a social construct, and as such we have definitions for
    Genders.

    Right now there happens to only be two, but we'll see what the
    future holds.
    """

    gender_type: "DestinyGender"
    display_properties: "DestinyDisplayPropertiesDefinition"
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyItemGearsetBlockDefinition:
    """'If an item has a related gearset, this is the list of items in that
    set, and an unlock expression that evaluates to a number representing the
    progress toward gearset completion (a very rare use for unlock
    expressions!)"""

    tracking_value_max: int
    item_list: t.Sequence[int]


@dt.dataclass(frozen=True)
class DestinyItemSackBlockDefinition:
    """'Some items are "sacks" - they can be "opened" to produce other items. This is information related to its sack status, mostly UI strings. Engrams are an example of items that are considered to be "Sacks"."""

    detail_action: str
    open_action: str
    select_item_count: int
    vendor_sack_type: str
    open_on_acquire: bool


@dt.dataclass(frozen=True)
class DestinyItemSocketBlockDefinition:
    """'If defined, the item has at least one socket."""

    detail: str
    socket_entries: t.Sequence["DestinyItemSocketEntryDefinition"]
    intrinsic_sockets: t.Sequence["DestinyItemIntrinsicSocketEntryDefinition"]
    socket_categories: t.Sequence["DestinyItemSocketCategoryDefinition"]


@dt.dataclass(frozen=True)
class DestinyItemSocketEntryDefinition:
    """'The definition information for a specific socket on an item.

    This will determine how the socket behaves in-game.
    """

    socket_type_hash: int
    single_initial_item_hash: int
    reusable_plug_items: t.Sequence["DestinyItemSocketEntryPlugItemDefinition"]
    prevent_initialization_on_vendor_purchase: bool
    hide_perks_in_item_tooltip: bool
    plug_sources: "SocketPlugSources"
    reusable_plug_set_hash: int
    randomized_plug_set_hash: int
    default_visible: bool


@dt.dataclass(frozen=True)
class DestinyItemSocketEntryPlugItemDefinition:
    """'The definition of a known, reusable plug that can be applied to a
    socket."""

    plug_item_hash: int


@dt.dataclass(frozen=True)
class DestinyItemSocketEntryPlugItemRandomizedDefinition:
    currently_can_roll: bool
    plug_item_hash: int


@dt.dataclass(frozen=True)
class DestinyItemIntrinsicSocketEntryDefinition:
    """'Represents a socket that has a plug associated with it intrinsically.

    This is useful for situations where the weapon needs to have a
    visual plug/Mod on it, but that plug/Mod should never change.
    """

    plug_item_hash: int
    socket_type_hash: int
    default_visible: bool


@dt.dataclass(frozen=True)
class DestinyItemSocketCategoryDefinition:
    """'Sockets are grouped into categories in the UI.

    These define which category and which sockets are under that
    category.
    """

    socket_category_hash: int
    socket_indexes: t.Sequence[int]


@dt.dataclass(frozen=True)
class DestinyItemSummaryBlockDefinition:
    """'This appears to be information used when rendering rewards.

    We don't currently use it on BNet.
    """

    sort_priority: int


@dt.dataclass(frozen=True)
class DestinyItemTalentGridBlockDefinition:
    """'This defines information that can only come from a talent grid on an
    item.

    Items mostly have negligible talent grid data these days, but
    instanced items still retain grids as a source for some of this
    common information. Builds/Subclasses are the only items left that
    still have talent grids with meaningful Nodes.
    """

    talent_grid_hash: int
    item_detail_string: str
    build_name: str
    hud_damage_type: "DamageType"
    hud_icon: str


@dt.dataclass(frozen=True)
class DestinyTalentGridDefinition:
    """'The time has unfortunately come to talk about Talent Grids. Talent
    Grids are the most complex and unintuitive part of the Destiny Definition
    data. Grab a cup of coffee before we begin, I can wait. Talent Grids were
    the primary way that items could be customized in Destiny 1. In Destiny 2,
    for now, talent grids have become exclusively used by Subclass/Build items:
    but the system is still in place for it to be used by items should the
    direction change back toward talent grids. Talent Grids have Nodes: the
    visual circles on the talent grid detail screen that have icons and can be
    activated if you meet certain requirements and pay costs. The actual visual
    data and effects, however, are driven by the "Steps" on Talent Nodes. Any
    given node will have 1:M of these steps, and the specific step that will be
    considered the "current" step (and thus the dictator of all benefits,
    visual state, and activation requirements on the Node) will almost always
    not be determined until an instance of the item is created. This is how, in
    Destiny 1, items were able to have such a wide variety of what users saw as
    "Perks": they were actually Talent Grids with nodes that had a wide variety
    of Steps, randomly chosen at the time of item creation. Now that Talent
    Grids are used exclusively by subclasses and builds, all of the properties
    within still apply: but there are additional visual elements on the
    Subclass/Build screens that are superimposed on top of the talent nodes.
    Unfortunately, BNet doesn't have this data: if you want to build a subclass
    screen, you will have to provide your own "decorative" assets, such as the
    visual connectors between nodes and the fancy colored-fire-bathed character
    standing behind the nodes.

    DestinyInventoryItem.talentGrid.talentGridHash defines an item's linked Talent Grid, which brings you to this definition that contains enough satic data about talent grids to make your head spin. These *must* be combined with instanced data - found when live data returns DestinyItemTalentGridComponent - in order to derive meaning. The instanced data will reference nodes and steps within these definitions, which you will then have to look up in the definition and combine with the instanced data to give the user the visual representation of their item's talent grid.
    """

    max_grid_level: int
    grid_level_per_column: int
    progression_hash: int
    nodes: t.Sequence["DestinyTalentNodeDefinition"]
    exclusive_sets: t.Sequence["DestinyTalentNodeExclusiveSetDefinition"]
    independent_node_indexes: t.Sequence[int]
    groups: t.Mapping[str, "DestinyTalentExclusiveGroup"]
    node_categories: t.Sequence["DestinyTalentNodeCategory"]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyTalentNodeDefinition:
    """'Talent Grids on items have Nodes.

    These nodes have positions in the talent grid's UI, and contain
    "Steps" (DestinyTalentNodeStepDefinition), one of whom will be the
    "Current" step. The Current Step determines the visual properties of
    the node, as well as what the node grants when it is activated. See
    DestinyTalentGridDefinition for a more complete overview of how
    Talent Grids work, and how they are used in Destiny 2 (and how they
    were used in Destiny 1).
    """

    node_index: int
    node_hash: int
    row: int
    column: int
    prerequisite_node_indexes: t.Sequence[int]
    binary_pair_node_index: int
    auto_unlocks: bool
    last_step_repeats: bool
    is_random: bool
    random_activation_requirement: t.Any
    is_random_repurchasable: bool
    steps: t.Sequence["DestinyNodeStepDefinition"]
    exclusive_with_node_hashes: t.Sequence[int]
    random_start_progression_bar_at_progression: int
    layout_identifier: str
    group_hash: int
    lore_hash: int
    node_style_identifier: str
    ignore_for_completion: bool


@dt.dataclass(frozen=True)
class DestinyNodeActivationRequirement:
    """'Talent nodes have requirements that must be met before they can be
    activated.

    This describes the material costs, the Level of the Talent Grid's
    progression required, and other conditional information that limits
    whether a talent node can be activated.
    """

    grid_level: int
    material_requirement_hashes: t.Sequence[int]


@dt.dataclass(frozen=True)
class DestinyNodeStepDefinition:
    """'This defines the properties of a "Talent Node Step". When you see a
    talent node in game, the actual visible properties that you see (its icon,
    description, the perks and stats it provides) are not provided by the Node
    itself, but rather by the currently active Step on the node. When a Talent
    Node is activated, the currently active step's benefits are conferred upon
    the item and character. The currently active step on talent nodes are
    determined when an item is first instantiated. Sometimes it is random,
    sometimes it is more deterministic (particularly when a node has only a
    single step).

    Note that, when dealing with Talent Node Steps, you must ensure that you have the latest version of content. stepIndex and nodeStepHash - two ways of identifying the step within a node - are both content version dependent, and thus are subject to change between content updates.
    """

    display_properties: t.Any
    step_index: int
    node_step_hash: int
    interaction_description: str
    damage_type: "DamageType"
    damage_type_hash: int
    activation_requirement: t.Any
    can_activate_next_step: bool
    next_step_index: int
    is_next_step_random: bool
    perk_hashes: t.Sequence[int]
    start_progression_bar_at_progress: int
    stat_hashes: t.Sequence[int]
    affects_quality: bool
    step_groups: t.Any
    affects_level: bool
    socket_replacements: t.Sequence["DestinyNodeSocketReplaceResponse"]


@dt.dataclass(frozen=True)
class DestinyNodeSocketReplaceResponse:
    """'This is a bit of an odd duck.

    Apparently, if talent nodes steps have this data, the game will go
    through on step activation and alter the first Socket it finds on
    the item that has a type matching the given socket type, inserting
    the indicated plug item.
    """

    socket_type_hash: int
    plug_item_hash: int


@dt.dataclass(frozen=True)
class DestinyDamageTypeDefinition:
    """'All damage types that are possible in the game are defined here, along
    with localized info and icons as needed."""

    display_properties: t.Any
    transparent_icon_path: str
    show_icon: bool
    enum_value: "DamageType"
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyTalentNodeExclusiveSetDefinition:
    """'The list of indexes into the Talent Grid's "nodes" property for nodes
    in this exclusive set.

    (See DestinyTalentNodeDefinition.nodeIndex)
    """

    node_indexes: t.Sequence[int]


@dt.dataclass(frozen=True)
class DestinyTalentExclusiveGroup:
    """'As of Destiny 2, nodes can exist as part of "Exclusive Groups".

    These differ from exclusive sets in that, within the group, many
    nodes can be activated. But the act of activating any node in the
    group will cause "opposing" nodes (nodes in groups that are not
    allowed to be activated at the same time as this group) to
    deactivate.
    """

    group_hash: int
    lore_hash: int
    node_hashes: t.Sequence[int]
    opposing_group_hashes: t.Sequence[int]
    opposing_node_hashes: t.Sequence[int]


@dt.dataclass(frozen=True)
class DestinyTalentNodeCategory:
    """'An artificial construct provided by Bungie.Net, where we attempt to
    group talent nodes by functionality.

    This is a single set of references to Talent Nodes that share a
    common trait or purpose.
    """

    identifier: str
    is_lore_driven: bool
    display_properties: t.Any
    node_hashes: t.Sequence[int]


@dt.dataclass(frozen=True)
class DestinyItemPerkEntryDefinition:
    """'An intrinsic perk on an item, and the requirements for it to be
    activated."""

    requirement_display_string: str
    perk_hash: int
    perk_visibility: "ItemPerkVisibility"


@dt.dataclass(frozen=True)
class DestinyItemCategoryDefinition:
    """'In an attempt to categorize items by type, usage, and other interesting
    properties, we created DestinyItemCategoryDefinition: information about
    types that is assembled using a set of heuristics that examine the
    properties of an item such as what inventory bucket it's in, its item type
    name, and whether it has or is missing certain blocks of data.

    This heuristic is imperfect, however. If you find an item
    miscategorized, let us know on the Bungie API forums! We then
    populate all of the categories that we think an item belongs to in
    its DestinyInventoryItemDefinition.itemCategoryHashes property. You
    can use that to provide your own custom item filtering, sorting,
    aggregating... go nuts on it! And let us know if you see more
    categories that you wish would be added!
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    visible: bool
    deprecated: bool
    short_title: str
    item_type_regex: str
    grant_destiny_breaker_type: "DestinyBreakerType"
    plug_category_identifier: str
    item_type_regex_not: str
    origin_bucket_identifier: str
    grant_destiny_item_type: "DestinyItemType"
    grant_destiny_sub_type: "DestinyItemSubType"
    grant_destiny_class: "DestinyClass"
    trait_id: str
    grouped_category_hashes: t.Sequence[int]
    parent_category_hashes: t.Sequence[int]
    group_category_only: bool
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyProgressionRewardItemQuantity:
    rewarded_at_progression_level: int
    acquisition_behavior: "DestinyProgressionRewardItemAcquisitionBehavior"
    ui_display_style: str
    claim_unlock_display_strings: t.Sequence[str]
    item_hash: int
    item_instance_id: int
    quantity: int
    has_conditional_visibility: bool


@dt.dataclass(frozen=True)
class DestinyRaceDefinition:
    """'In Destiny, "Races" are really more like "Species".

    Sort of. I mean, are the Awoken a separate species from humans? I'm
    not sure. But either way, they're defined here. You'll see Exo,
    Awoken, and Human as examples of these Species. Players will choose
    one for their character.
    """

    display_properties: "DestinyDisplayPropertiesDefinition"
    race_type: "DestinyRace"
    gendered_race_names: t.Mapping[str, str]
    gendered_race_names_by_gender_hash: t.Mapping[str, str]
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyClassDefinition:
    """'Defines a Character Class in Destiny 2.

    These are types of characters you can play, like Titan, Warlock, and
    Hunter.
    """

    class_type: "DestinyClass"
    display_properties: "DestinyDisplayPropertiesDefinition"
    gendered_class_names: t.Mapping[str, str]
    gendered_class_names_by_gender_hash: t.Mapping[str, str]
    mentor_vendor_hash: int
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyUnlockDefinition:
    """'Unlock Flags are small bits (literally, a bit, as in a boolean value)
    that the game server uses for an extremely wide range of state checks,
    progress storage, and other interesting tidbits of information."""

    display_properties: t.Any
    hash: int
    index: int
    redacted: bool


@dt.dataclass(frozen=True)
class DestinyEntitySearchResult:
    """'The results of a search for Destiny content.

    This will be improved on over time, I've been doing some
    experimenting to see what might be useful.
    """

    suggested_words: t.Sequence[str]
    results: t.Any


@dt.dataclass(frozen=True)
class DestinyEntitySearchResultItem:
    """'An individual Destiny Entity returned from the entity search."""

    hash: int
    entity_type: str
    display_properties: t.Any
    weight: float


from bungieapi.generated.types import BungieMembershipType  # noqa: E402
from bungieapi.generated.types.dates import DateRange  # noqa: E402

# imported at the end to do not case circular imports for type annotations
from bungieapi.generated.types.destiny import BucketCategory  # noqa: E402
from bungieapi.generated.types.destiny import BucketScope  # noqa: E402
from bungieapi.generated.types.destiny import DamageType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyActivityModeCategory  # noqa: E402
from bungieapi.generated.types.destiny import DestinyActivityNavPointType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyAmmunitionType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyBreakerType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyClass  # noqa: E402
from bungieapi.generated.types.destiny import DestinyGatingScope  # noqa: E402
from bungieapi.generated.types.destiny import DestinyGender  # noqa: E402
from bungieapi.generated.types.destiny import DestinyItemQuantity  # noqa: E402
from bungieapi.generated.types.destiny import DestinyItemSortType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyItemSubType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyItemType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyObjectiveGrantStyle  # noqa: E402
from bungieapi.generated.types.destiny import DestinyProgressionScope  # noqa: E402
from bungieapi.generated.types.destiny import DestinyRace  # noqa: E402
from bungieapi.generated.types.destiny import DestinyStatAggregationType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyStatCategory  # noqa: E402
from bungieapi.generated.types.destiny import DestinyUnlockValueUIStyle  # noqa: E402
from bungieapi.generated.types.destiny import DestinyVendorProgressionType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyVendorReplyType  # noqa: E402
from bungieapi.generated.types.destiny import DyeReference  # noqa: E402
from bungieapi.generated.types.destiny import EquippingItemBlockAttributes  # noqa: E402
from bungieapi.generated.types.destiny import ItemLocation  # noqa: E402
from bungieapi.generated.types.destiny import ItemPerkVisibility  # noqa: E402
from bungieapi.generated.types.destiny import SocketPlugSources  # noqa: E402
from bungieapi.generated.types.destiny import SpecialItemType  # noqa: E402
from bungieapi.generated.types.destiny import TierType  # noqa: E402
from bungieapi.generated.types.destiny import VendorInteractionType  # noqa: E402
from bungieapi.generated.types.destiny import (  # noqa: E402
    DestinyProgressionRewardItemAcquisitionBehavior,
    DestinyProgressionStepDisplayEffect,
    DestinyVendorInteractionRewardSelection,
    DestinyVendorItemRefundPolicy,
    VendorDisplayCategorySortOrder,
)
from bungieapi.generated.types.destiny.constants import (
    DestinyEnvironmentLocationMapping,
)  # noqa: E402
from bungieapi.generated.types.destiny.definitions.animations import (
    DestinyAnimationReference,
)  # noqa: E402
from bungieapi.generated.types.destiny.definitions.common import (  # noqa: E402
    DestinyDisplayPropertiesDefinition,
    DestinyIconSequenceDefinition,
)
from bungieapi.generated.types.destiny.definitions.items import (
    DestinyDerivedItemCategoryDefinition,
)  # noqa: E402
from bungieapi.generated.types.destiny.definitions.sources import (
    DestinyItemSourceDefinition,
)  # noqa: E402
from bungieapi.generated.types.destiny.definitions.vendors import (
    DestinyVendorLocationDefinition,
)  # noqa: E402
from bungieapi.generated.types.destiny.historical_stats.definitions import (
    DestinyActivityModeType,
)  # noqa: E402
from bungieapi.generated.types.interpolation import InterpolationPoint  # noqa: E402
from bungieapi.generated.types.links import HyperlinkReference  # noqa: E402
