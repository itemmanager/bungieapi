# generated by update to not change manually
import dataclasses as dt
import typing as t


@dt.dataclass(frozen=True)
class DestinyItemComponent:
    """'The base item component, filled with properties that are generally
    useful to know in any item request or that don't feel worthwhile to put in
    their own component."""

    item_hash: int
    item_instance_id: int
    quantity: int
    bind_status: "ItemBindStatus"
    location: "ItemLocation"
    bucket_hash: int
    transfer_status: "TransferStatuses"
    lockable: bool
    state: "ItemState"
    override_style_item_hash: int
    expiration_date: str
    is_wrapper: bool
    tooltip_notification_indexes: t.Sequence[int]
    metric_hash: int
    metric_objective: "DestinyObjectiveProgress"
    version_number: int
    item_value_visibility: t.Sequence[bool]


@dt.dataclass(frozen=True)
class DestinyItemPerksComponent:
    """'Instanced items can have perks: benefits that the item bestows.

    These are related to DestinySandboxPerkDefinition, and sometimes - but not always - have human readable info. When they do, they are the icons and text that you see in an item's tooltip.
    Talent Grids, Sockets, and the item itself can apply Perks, which are then summarized here for your convenience.
    """

    perks: t.Sequence["DestinyPerkReference"]


@dt.dataclass(frozen=True)
class DestinyItemObjectivesComponent:
    """'Items can have objectives and progression.

    When you request this block, you will obtain information about any
    Objectives and progression tied to this item.
    """

    objectives: t.Sequence["DestinyObjectiveProgress"]
    flavor_objective: "DestinyObjectiveProgress"
    date_completed: str


@dt.dataclass(frozen=True)
class DestinyItemInstanceComponent:
    """'If an item is "instanced", this will contain information about the
    item's instance that doesn't fit easily into other components.

    One might say this is the "essential" instance data for the item.
    Items are instanced if they require information or state that can
    vary. For instance, weapons are Instanced: they are given a unique
    identifier, uniquely generated stats, and can have their properties
    altered. Non-instanced items have none of these things: for
    instance, Glimmer has no unique properties aside from how much of it
    you own. You can tell from an item's definition whether it will be
    instanced or not by looking at the DestinyInventoryItemDefinition's
    definition.inventory.isInstanceItem property.
    """

    damage_type: "DamageType"
    damage_type_hash: int
    primary_stat: "DestinyStat"
    item_level: int
    quality: int
    is_equipped: bool
    can_equip: bool
    equip_required_level: int
    unlock_hashes_required_to_equip: t.Sequence[int]
    cannot_equip_reason: "EquipFailureReason"
    breaker_type: int
    breaker_type_hash: int
    energy: "DestinyItemInstanceEnergy"


@dt.dataclass(frozen=True)
class DestinyItemInstanceEnergy:
    energy_type_hash: int
    energy_type: "DestinyEnergyType"
    energy_capacity: int
    energy_used: int
    energy_unused: int


@dt.dataclass(frozen=True)
class DestinyItemRenderComponent:
    """'Many items can be rendered in 3D.

    When you request this block, you will obtain the custom data needed
    to render this specific instance of the item.
    """

    use_custom_dyes: bool
    art_regions: t.Mapping[str, int]


@dt.dataclass(frozen=True)
class DestinyItemStatsComponent:
    """'If you want the stats on an item's instanced data, get this component.
    These are stats like Attack, Defense etc... and *not* historical stats.

    Note that some stats have additional computation in-game at runtime - for instance, Magazine Size - and thus these stats might not be 100% accurate compared to what you see in-game for some stats. I know, it sucks. I hate it too.
    """

    stats: t.Mapping[str, "DestinyStat"]


@dt.dataclass(frozen=True)
class DestinyItemSocketsComponent:
    """'Instanced items can have sockets, which are slots on the item where
    plugs can be inserted.

    Sockets are a bit complex: be sure to examine the documentation on
    the DestinyInventoryItemDefinition's "socket" block and elsewhere on
    these objects for more details.
    """

    sockets: t.Sequence["DestinyItemSocketState"]


@dt.dataclass(frozen=True)
class DestinyItemSocketState:
    """'The status of a given item's socket.

    (which plug is inserted, if any: whether it is enabled, what
    "reusable" plugs can be inserted, etc...) If I had it to do over,
    this would probably have a DestinyItemPlug representing the inserted
    item instead of most of these properties. :shrug:
    """

    plug_hash: int
    is_enabled: bool
    is_visible: bool
    enable_fail_indexes: t.Sequence[int]


@dt.dataclass(frozen=True)
class DestinyItemTalentGridComponent:
    """'Well, we're here in Destiny 2, and Talent Grids are unfortunately still
    around.

    The good news is that they're pretty much only being used for
    certain base information on items and for Builds/Subclasses. The bad
    news is that they still suck. If you really want this information,
    grab this component. An important note is that talent grids are
    defined as such: A Grid has 1:M Nodes, which has 1:M Steps. Any
    given node can only have a single step active at one time, which
    represents the actual visual contents and effects of the Node (for
    instance, if you see a "Super Cool Bonus" node, the actual icon and
    text for the node is coming from the current Step of that node).
    Nodes can be grouped into exclusivity sets *and* as of D2,
    exclusivity groups (which are collections of exclusivity sets that
    affect each other). See DestinyTalentGridDefinition for more
    information. Brace yourself, the water's cold out there in the deep
    end.
    """

    talent_grid_hash: int
    nodes: t.Sequence["DestinyTalentNode"]
    is_grid_complete: bool
    grid_progression: "DestinyProgression"


# imported at the end to do not case circular imports for type annotations
from bungieapi.generated.types.destiny import DamageType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyEnergyType  # noqa: E402
from bungieapi.generated.types.destiny import DestinyProgression  # noqa: E402
from bungieapi.generated.types.destiny import DestinyStat  # noqa: E402
from bungieapi.generated.types.destiny import DestinyTalentNode  # noqa: E402
from bungieapi.generated.types.destiny import EquipFailureReason  # noqa: E402
from bungieapi.generated.types.destiny import ItemBindStatus  # noqa: E402
from bungieapi.generated.types.destiny import ItemLocation  # noqa: E402
from bungieapi.generated.types.destiny import ItemState  # noqa: E402
from bungieapi.generated.types.destiny import TransferStatuses  # noqa: E402
from bungieapi.generated.types.destiny.perks import DestinyPerkReference  # noqa: E402
from bungieapi.generated.types.destiny.quests import (
    DestinyObjectiveProgress,
)  # noqa: E402
