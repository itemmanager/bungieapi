# generated by update to not change manually
import dataclasses as dt
import typing as t


@dt.dataclass(frozen=True)
class DestinyProgression:
    """'Information about a current character's status with a Progression.

    A progression is a value that can increase with activity and has
    levels. Think Character Level and Reputation Levels. Combine this
    "live" data with the related DestinyProgressionDefinition for a full
    picture of the Progression.
    """

    progression_hash: int
    daily_progress: int
    daily_limit: int
    weekly_progress: int
    weekly_limit: int
    current_progress: int
    level: int
    level_cap: int
    step_index: int
    progress_to_next_level: int
    next_level_at: int
    current_reset_count: int
    season_resets: t.Sequence["DestinyProgressionResetEntry"]
    reward_item_states: t.Sequence["DestinyProgressionRewardItemState"]


@dt.dataclass(frozen=True)
class DestinyProgressionResetEntry:
    """'Represents a season and the number of resets you had in that season.

    We do not necessarily - even for progressions with resets - track it over all seasons. So be careful and check the season numbers being returned.
    """

    season: int
    resets: int


DestinyProgressionRewardItemState = t.Any
DestinyProgressionScope = t.Any
DestinyProgressionStepDisplayEffect = t.Any


@dt.dataclass(frozen=True)
class DestinyItemQuantity:
    """'Used in a number of Destiny contracts to return data about an item
    stack and its quantity.

    Can optionally return an itemInstanceId if the item is instanced - in which case, the quantity returned will be 1. If it's not... uh, let me know okay? Thanks.
    """

    item_hash: int
    item_instance_id: int
    quantity: int
    has_conditional_visibility: bool


TierType = t.Any
BucketScope = t.Any
BucketCategory = t.Any
ItemLocation = t.Any
DestinyStatAggregationType = t.Any
DestinyStatCategory = t.Any
EquippingItemBlockAttributes = t.Any
DestinyAmmunitionType = t.Any


@dt.dataclass(frozen=True)
class DyeReference:
    channel_hash: int
    dye_hash: int


DestinyVendorProgressionType = t.Any
VendorDisplayCategorySortOrder = t.Any
DestinyVendorInteractionRewardSelection = t.Any
DestinyVendorReplyType = t.Any
VendorInteractionType = t.Any
DestinyItemSortType = t.Any
DestinyVendorItemRefundPolicy = t.Any
DestinyGatingScope = t.Any
SocketTypeActionType = t.Any
DestinySocketVisibility = t.Any
DestinySocketCategoryStyle = t.Any
ActivityGraphNodeHighlightType = t.Any
DestinyUnlockValueUIStyle = t.Any
DestinyObjectiveGrantStyle = t.Any
DamageType = t.Any
DestinyActivityNavPointType = t.Any
DestinyActivityModeCategory = t.Any
DestinyItemSubType = t.Any
DestinyGraphNodeState = t.Any
DestinyPresentationNodeType = t.Any
DestinyScope = t.Any
DestinyPresentationDisplayStyle = t.Any
DestinyRecordValueStyle = t.Any
DestinyGender = t.Any
DestinyRecordToastStyle = t.Any
DestinyPresentationScreenStyle = t.Any
PlugUiStyles = t.Any
PlugAvailabilityMode = t.Any
DestinyEnergyType = t.Any
SocketPlugSources = t.Any
ItemPerkVisibility = t.Any
SpecialItemType = t.Any
DestinyItemType = t.Any
DestinyClass = t.Any
DestinyBreakerType = t.Any
DestinyProgressionRewardItemAcquisitionBehavior = t.Any
ItemBindStatus = t.Any
TransferStatuses = t.Any
ItemState = t.Any
DestinyGameVersions = t.Any
DestinyComponentType = t.Any
DestinyPresentationNodeState = t.Any
DestinyRecordState = t.Any
DestinyCollectibleState = t.Any
DestinyPartyMemberStates = t.Any
DestinyGamePrivacySetting = t.Any
DestinyJoinClosedReasons = t.Any
DestinyRace = t.Any


@dt.dataclass(frozen=True)
class DestinyActivity:
    """'Represents the "Live" data that we can obtain about a Character's
    status with a specific Activity.

    This will tell you whether the character can participate in the
    activity, as well as some other basic mutable information. Meant to
    be combined with static DestinyActivityDefinition data for a full
    picture of the Activity.
    """

    activity_hash: int
    is_new: bool
    can_lead: bool
    can_join: bool
    is_completed: bool
    is_visible: bool
    display_level: int
    recommended_light: int
    difficulty_tier: "DestinyActivityDifficultyTier"
    challenges: t.Sequence["DestinyChallengeStatus"]
    modifier_hashes: t.Sequence[int]
    boolean_activity_options: t.Mapping[str, bool]
    loadout_requirement_index: int


DestinyActivityDifficultyTier = t.Any


@dt.dataclass(frozen=True)
class DestinyStat:
    """'Represents a stat on an item *or* Character (NOT a Historical Stat, but
    a physical attribute stat like Attack, Defense etc...)"""

    stat_hash: int
    value: int


EquipFailureReason = t.Any


@dt.dataclass(frozen=True)
class DestinyTalentNode:
    """'I see you've come to find out more about Talent Nodes.

    I'm so sorry. Talent Nodes are the conceptual, visual nodes that
    appear on Talent Grids. Talent Grids, in Destiny 1, were found on
    almost every instanced item: they had Nodes that could be activated
    to change the properties of the item. In Destiny 2, Talent Grids
    only exist for Builds/Subclasses, and while the basic concept is the
    same (Nodes can be activated once you've gained sufficient
    Experience on the Item, and provide effects), there are some new
    concepts from Destiny 1. Examine DestinyTalentGridDefinition and its
    subordinates for more information. This is the "Live" information
    for the current status of a Talent Node on a specific item. Talent
    Nodes have many Steps, but only one can be active at any one time:
    and it is the Step that determines both the visual and the game
    state-changing properties that the Node provides. Examine this and
    DestinyTalentNodeStepDefinition carefully. *IMPORTANT NOTE* Talent
    Nodes are, unfortunately, Content Version DEPENDENT. Though they
    refer to hashes for Nodes and Steps, those hashes are not guaranteed
    to be immutable across content versions. This is a source of great
    exasperation for me, but as a result anyone using Talent Grid data
    must ensure that the content version of their static content matches
    that of the server responses before showing or making decisions
    based on talent grid data.
    """

    node_index: int
    node_hash: int
    state: "DestinyTalentNodeState"
    is_activated: bool
    step_index: int
    materials_to_upgrade: t.Sequence["DestinyMaterialRequirement"]
    activation_grid_level: int
    progress_percent: float
    hidden: bool
    node_stats_block: t.Any


DestinyTalentNodeState = t.Any


@dt.dataclass(frozen=True)
class DestinyTalentNodeStatBlock:
    """'This property has some history.

    A talent grid can provide stats on both the item it's related to and
    the character equipping the item. This returns data about those stat
    bonuses.
    """

    current_step_stats: t.Sequence["DestinyStat"]
    next_step_stats: t.Sequence["DestinyStat"]


DestinyVendorFilter = t.Any
VendorItemStatus = t.Any


@dt.dataclass(frozen=True)
class DestinyUnlockStatus:
    """'Indicates the status of an "Unlock Flag" on a Character or Profile.

    These are individual bits of state that can be either set or not
    set, and sometimes provide interesting human-readable information in
    their related DestinyUnlockDefinition.
    """

    unlock_hash: int
    is_set: bool


DestinyVendorItemState = t.Any


@dt.dataclass(frozen=True)
class DestinyEquipItemResults:
    """'The results of a bulk Equipping operation performed through the Destiny
    API."""

    equip_results: t.Sequence["DestinyEquipItemResult"]


@dt.dataclass(frozen=True)
class DestinyEquipItemResult:
    """'The results of an Equipping operation performed through the Destiny
    API."""

    item_instance_id: int
    equip_status: "PlatformErrorCodes"


# imported at the end to do not case circular imports for type annotations
from bungieapi.generated.types.destiny.challenges import (
    DestinyChallengeStatus,
)  # noqa: E402
from bungieapi.generated.types.destiny.definitions import (
    DestinyMaterialRequirement,
)  # noqa: E402
from bungieapi.generated.types.exceptions import PlatformErrorCodes  # noqa: E402
